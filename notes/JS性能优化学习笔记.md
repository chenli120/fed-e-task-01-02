任务二：JavaScript 性能优化-如何编写高性能的JavaScript

**内容概要**
    ·内存管理
    ·垃圾回收与常见的GC算法
    ·V8引擎的垃圾回收
    ·Performance工具
    ·代码优化实例

**1.JavaScript 内存管理 Memory Management**
    ·内存为什么需要管理
    function fn() {
        arrList = []
        arrList[1000000] = 'lg is a coder'
    }
    fn()

    ·内存管理介绍
        ·内存： 由刻度写单元组成，表示一片可操作的空间
        ·管理：人为的去操作一片空间的申请、使用和释放
        ·内存管理：开发者主动申请空间、使用空间、释放空间
        ·管理流程：申请-使用-释放
    ·JavaScript中的内存管理
        ·申请内存空间
        ·使用内存管理
        ·释放内存空间

**2.JavaScript中的垃圾回收**04
    ·JavaScript中的垃圾
        ·JavaScript中内存管理是自动的
        ·对象不再被**引用**时是垃圾
        ·对象不能**从根上访问**到时是垃圾
    ·JavaScript中的可达对象  03-reference.js
        ·可以访问到的对象就是可达对象（引用、作用域）
        ·可达的标准就是从根出发是否能够被找到
        ·JavaScript中的根就可以理解为是全局变量对象
    ·JavaScript中的引用和可达 04-Reachable-obj.js


**3.GC算法介绍**
    ·GC定义与作用
        ·GC就是垃圾回收机制的简写
        ·GC可以找到内存中的垃圾、并释放和回收空间
    ·GC里的垃圾是什么
        ·程序中不再需要使用的对象
            function func() {
                name = 'lg'
                return `${name} is a coder`
            }
            func()
        ·程序中不能再访问到的对象
            function func() {
                const name = 'lg'
                return `${name} is a coder`
            }
            func()
    ·GC算法介绍
        ·GC是一种机制，垃圾回收器完成具体的工作
        ·工作的内容就是查找垃圾释放空间、回收空间
        ·算法就是工作时查找和回收所遵循的规则
    ·常见GC算法
        ·引用计数
        ·标记清楚
        ·标记整理
        ·分代回收

**4.引用计数算法** 03-reference-count.js
    ·核心思想：设置引用数，判断当前引用数是否为0
    ·引用计数器
    ·引用关系改变时修改引用数字
    ·引用数字为0时立即回收
**5.引用计数算法优缺点**
    ·优点
        ·发现垃圾时立即回收
        ·最大限度减少程序暂停（减少程序卡顿时间）---应用程序过程中消耗内存，发现内存快被占满时，
    ·缺点
        ·无法回收**循环引用**的对象  04-circular-reference.js
        ·时间开销大（资源消耗大）---需要维护数值的变化，时刻监控引用数字是否修改，修改就需要耗时

**6·标记清楚算法的实现原理**
    ·核心思想： 分标记和清除两个阶段
    ·标记：遍历所有对象标记活动对象
    ·清除：遍历所有对象清除没有标记对象
    ·回收相应的对象
**7.标记清楚算法优缺点**
    ·优点
        ·相较引用计数算法，可以解决对象循环引用不能回收的问题
    ·缺点
        ·空间碎片化：由于回收的地址不连续，导致空间碎片化，空间不能最大化使用
        ·不能立即回收垃圾对象，回收的时候程序会暂停
        ·不能立即回收垃圾对象，回收的时候程序会暂停

**8·标记整理算法的实现原理**
    ·标记整理可以看做是标记清楚的增强
    ·标记阶段的操作和标记清楚一致
    ·清除阶段会先执行整理，移动对象位置
    ·回收相应的对象
**9.标记整理算法优点**
    ·优点：最大化利用内存中的空闲空间，减少碎片化空间
    ·缺点：不能立即回收垃圾对象，回收的时候程序会暂停

**10.认识V8**
    ·V8是一款主流的JavaScript执行引擎
    ·V8采用即时编译
    ·V8内存设限 64位不超过1.5G, 32位中不超过800M（本身为浏览器而设置，这个大小合适够用；垃圾回收机制，大了会超过用户感知）
**11.V8垃圾回收策略**
    ·采用分代回收的思想
    ·内存分为新生代、老生代
    ·针对不同对象采取不同算法
    ·V8中常见GC算法
        ·分代回收
        ·空间复制
        ·标记清楚
        ·标记整理
        ·标记增量
**12. V8如何回收新生代对象**
    ·V8内存分配
        ·V8内存空间一分为二
        ·小空间用于存储新生代对象（32M | 16M）
        ·新生代指的是存活时间教短的对象
    ·新生代对象回收实现
        ·回收过程采用**复制算法 + 标记整理**
        ·新生代内存区分为两个等大小空间
        ·使用空间from,空闲空间为To
        ·活动对象存储于From空间
        ·标记整理后活动对象拷贝至To
        ·From于To交换空间完成释放
    ·回收细节说明
        ·拷贝过程过程中可能出现晋升
        ·晋升就是讲新生代对象移动至老生代
        ·一轮GC还存活的新生代需要晋升
        ·To空间的使用率超过25%
**13. V8如何回收老生代对象**
    ·老生代对象说明
        ·老生代对象存放在右侧老生代区域
        ·64位操作系统1.4G，32位操作系统700M
        ·老生代对象是指存活时间较长的对象
    ·回收实现
        ·主要采用**标记清除、标记整理、增量标记算法**
        ·首先使用标记清除完成垃圾空间的回收
        ·采用标记整理进行空间优化
        ·采用增量标记进行效率优化
    ·细节对比
        ·新生代区域垃圾回收使用空间换时间
        ·老生代区域垃圾回收不适合复制算法（存储区域比较大，等分会浪费空间；对象存储比较多，复制会浪费时间）
    ·增量标记如何优化垃圾回收
        垃圾回收时会阻塞程序的执行，增量标记将一整段垃圾回收操作分成几段进行（直接可达，间接可达，完成清理一步一步执行），实现垃圾回收与程序回收的交替执行，提高用户体验



**14. Performance工具介绍**
    ·为什么使用Performance
        ·GC的目的是为了实现内存空间的良性循环
        ·良性循环的基石是合理使用内存空间
        ·时刻关注才能确定是否合理
        ·Performance提供多种监控方式
        ==》通过时刻监控内存
    ·Performance使用步骤
        ·打开浏览器输入目标网址
        ·进入开发人员工具面板，选择性能
        ·开启录制功能，访问具体界面
        ·执行用户行为，一段时间后停止录制
        ·分析界面中记录的内存信息
**15. 内存问题的体现**
    ·内存问题的外在表现
        ·页面出现延迟加载或经常性暂停（内存泄漏）
        ·页面持续性出现糟糕的性能（内存膨胀--当前应用程序的本身为了达到最优效果，申请的内存空间远超内存大小）
        ·页面的性能随时间延长越来越差
    
**16. 监控内存的几种方式**
    ·界定内存问题的标准
        ·内存泄漏：内存使用持续升高
        ·内存膨胀：在多数设备上都存在性能问题
        ·频繁垃圾回收：通过内存变化图进行分析
    ·监控内存的几种方式
        ·浏览器任务管理器
        ·Timeline时序图记录
        ·堆快照查找分离DOM
        ·判断是否存在频繁的垃圾回收
**17. 任务管理器监控内存**
    06-task-manage.html 用浏览器打开后shift+Esc调出任务管理器
        ·内存---原生内存，Dom节点占据的内存，如果数据不断变大，说明界面在不断创建新DOM
        ·JavaScript内存---js中的堆（小括号里面的数值是指界面当面中所有可达对象正在使用的内存大小，如果数值变大，要么在创建新对象或者现有对象在不断增长）
**18. Timeline时序图记录内存**
    07-timeline.html
**19. 是否存在频繁垃圾回收**
    ·为什么确定频繁垃圾回收
        ·GC工作时用用程序是停止的
        ·频繁且过长的GC会导致应用假死
        ·用户使用中感知应用卡顿
    ·确定方式
        ·Timeline中频繁的上升下降
        ·任务管理器中数据频繁的增加减小



**20. 代码优化介绍**
    ·如何精准测试JS性能
        ·本质上就是采集大量的执行样本进行数学统计和分析
        ·使用基于Benchmark.js的 http://jsperf.com/ 完成
    ·Jsperf使用流程
        ·使用GitHub账号登录
        ·填写个人信息（非必须）
        ·填写详细的测试用例信息（title、slug-必须唯一）
        ·填写准备代码（DOM操作时经常使用）
        ·填写必要的setup和teardown代码 （setup-前置步骤，比如打开手机；teardown-销毁操作释放内存，比如断开数据库连接）
        ·填写测试代码片段

**21. 慎用全局变量**
    08-global-variable.js
    ·为什么要慎用
        ·全局变量定义在全局执行上下文，是所有作用域链的顶端---时间消耗大，降低代码执行效率
        ·全局执行上下文一直存在于上下文执行栈，直到程序退出---对于GC工作不利，降低程序在运行中对内存的使用
        ·如果某个局部作用域出现了同名变量则会遮蔽或污染全局


**22. 通过原型对象添加附加方法**
    ·通过原型新增方法：在原型对象上新增实例对象需要的方法

**23. 避免使用属性访问方法的使用**
    ·JS中的面向对象
        ·JS不需要属性的访问方法（get, set），所有属性都是外部可见的
        ·使用属性访问方法只会增加一层重定义，没有访问的控制力
**24. for循环优化**
    ·let i=arr.length;i;i--
**25. 克隆优化节点操作**
    ·var newP = oldP.cloneNode(false)
**26. 直接量替换 new Object**
    var a = [1,2,3]
    var a1 = new Array(3)
    a1[0] = 1
    a1[1] = 2
    a1[2] = 3

